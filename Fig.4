# ====================================================
# Qsip tree data preparation
library(data.table)
library(stringr)
library(DESeq2)
library(Biostrings)

# 1. Read data
load("../../02-数据计算/qSIP_res_freeze_total_corrected √.rdata")

# 2. Growth rate and mortality rate up/down regulation (based on confidence interval overlap)

# Convert to long format based on P2 and P0 treatments
gd <- res$pop2[variable %in% c('growth','mortality'),]
P0 <- gd[protist=='P0',]
P2 <- gd[protist=='P2',]
gd <- merge(P2, P0, by = c('asv_id','soil','variable'), all = T)
gd[is.na(gd)] <- 0

# When both P2 and P0 growth or mortality CIs do not overlap 0, calculate log2FC = log2(P2/P0)
# When P0 CI overlaps 0 but P2 CI does not, mark as 'up'
# When P2 CI overlaps 0 but P0 CI does not, mark as 'down'
gd[variable=='growth' & `5%.x`>0 & `5%.y`<=0, 'log2FC'] <- 'up'
gd[variable=='growth' & `5%.x`<=0 & `5%.y`>0, 'log2FC'] <- 'down'
gd[variable=='growth' & `5%.x`<=0 & `5%.y`<=0, 'log2FC'] <- 'both_not_significant'
gd[variable=='growth' & `5%.x`>0 & `5%.y`>0, log2FC := log2(`50%.x`/`50%.y`)]

# For mortality, direction is opposite to growth, use 95% values to check CI overlap with 0
gd[variable=='mortality' & `95%.x`<0 & `95%.y`>=0, 'log2FC'] <- 'up'
gd[variable=='mortality' & `95%.x`>=0 & `95%.y`<0, 'log2FC'] <- 'down'
gd[variable=='mortality' & `95%.x`>=0 & `95%.y`>=0, 'log2FC'] <- 'both_not_significant'
gd[variable=='mortality' & `95%.x`<0 & `95%.y`<0, log2FC := log2(`50%.x`/`50%.y`)]

# Mark significant up or down regulation based on CI overlap
gd[variable=='growth' & `5%.x`>`95%.y`, 'label'] <- 'up'
gd[variable=='growth' & `5%.y`>`95%.x`, 'label'] <- 'down'

gd[variable=='mortality' & `95%.x`<`5%.y`, 'label'] <- 'up'
gd[variable=='mortality' & `95%.y`<`5%.x`, 'label'] <- 'down'

gd[log2FC=='both_not_significant','label'] <- NA  # If both treatments have CI overlapping 0, do not show significant up/down even if treatments don't overlap

# Split by soil and variable, rename columns, and merge into long format
BG <- gd[soil=='B' & variable=='growth',]
RG <- gd[soil=='R' & variable=='growth',]
BG <- BG[log2FC!='both_not_significant',]  # Keep only results other than both_not_significant for growth rate
RG <- RG[log2FC!='both_not_significant',]  # Keep only results other than both_not_significant for growth rate
BM <- gd[soil=='B' & variable=='mortality',]
RM <- gd[soil=='R' & variable=='mortality',]
setnames(BG, c('log2FC','label'), c('BG_log2FC','BG_label'))
setnames(RG, c('log2FC','label'), c('RG_log2FC','RG_label'))
setnames(BM, c('log2FC','label'), c('BM_log2FC','BM_label'))
setnames(RM, c('log2FC','label'), c('RM_log2FC','RM_label'))

# Horizontally merge data
gd <- merge(BG[,c(1,14,15)], RG[,c(1,14,15)], by = c('asv_id'), all = T)
gd <- merge(gd, BM[,c(1,14,15)], by = c('asv_id'), all = T)
gd <- merge(gd, RM[,c(1,14,15)], by = c('asv_id'), all = T)
gd <- gd[(!BG_log2FC %in% c(NA,'both_not_significant')) | (!RG_log2FC %in% c(NA,'both_not_significant')),] # Remove ASVs where growth rate in both soils is 'both_not_significant' or NA

rm(P0, P2, BG, RG, BM, RM)  # Remove intermediate variables


# 3. ASV abundance up/down regulation (Deseq2)

table <- res$table
group <- data.frame(sample_id=names(table)[1:12], 
                   soil=str_extract(names(table)[1:12], "^([BR])_(P\\d)_\\d", group=1),
                   protist=str_extract(names(table)[1:12], "^([BR])_(P\\d)_\\d", group=2))
group$protist <- factor(group$protist, levels=c('P0','P2'))
B <- table[,group[group$soil=='B','sample_id']]
R <- table[,group[group$soil=='R','sample_id']]
B <- B[which(rowSums(B)!=0),]  # Remove ASVs with zero abundance
R <- R[which(rowSums(R)!=0),]  # Remove ASVs with zero abundance
B2 <- as.data.frame(apply(B, 2, function(x){as.integer(round(x)/10)})) # Round to integers, DESeq requires integers. Using as.integer, R's integer range is -2147483648 to 2147483647 (2.147e+09), exceeding this range causes errors, so divide all data by 10
R2 <- as.data.frame(apply(R, 2, function(x){as.integer(round(x)/10)})) # Round to integers, DESeq requires integers. Using as.integer, R's integer range is -2147483648 to 2147483647 (2.147e+09), exceeding this range causes errors, so divide all data by 10
row.names(B2) <- row.names(B)  # Add ASV_id as row names
row.names(R2) <- row.names(R)  # Add ASV_id as row names

# DESeq2 workflow
# Step 1, construct DESeqDataSet object, see ?DESeqDataSetFromMatrix for details
dds_B <- DESeqDataSetFromMatrix(countData = B2, colData = group[group$soil=='B',], design = ~protist)
dds_R <- DESeqDataSetFromMatrix(countData = R2, colData = group[group$soil=='R',], design = ~protist)

# Step 2, differential analysis, see ?DESeq and ?results for details
dds_B <- DESeq(dds_B, parallel = T) # parallel = TRUE enables multi-threading. Warning is a bug: In serialize(data, node$con) :'package:stats' may not be available when loading
dds_R <- DESeq(dds_R, parallel = T) # parallel = TRUE enables multi-threading. Warning is a bug: In serialize(data, node$con) :'package:stats' may not be available when loading

# Step 3, extract results, merge with ASV table results, save as RData
res_B <- results(dds_B, contrast = c('protist', 'P2', 'P0'), pAdjustMethod = 'BH', alpha = 0.05) # Can change p-value adjustment method pAdjustMethod = 'fdr'
res_B <- as.data.frame(res_B[order(res_B$log2FoldChange, decreasing = T), ])  # Convert results to data frame and sort by log2FoldChange
res_R <- results(dds_R, contrast = c('protist', 'P2', 'P0'), pAdjustMethod = 'BH', alpha = 0.05) # Can change p-value adjustment method pAdjustMethod = 'fdr'
res_R <- as.data.frame(res_R[order(res_R$log2FoldChange, decreasing = T), ])  # Convert results to data frame and sort by log2FoldChange

# Format data
res_B$asv_id <- row.names(res_B)
res_B[which(res_B$log2FoldChange>0 & res_B$pvalue<0.05), 'BA_label'] <- 'up'
res_B[which(res_B$log2FoldChange<0 & res_B$pvalue<0.05), 'BA_label'] <- 'down'
names(res_B)[2] <- 'BA_log2FC'

res_R$asv_id <- row.names(res_R)
res_R[which(res_R$log2FoldChange>0 & res_R$pvalue<0.05), 'RA_label'] <- 'up'
res_R[which(res_R$log2FoldChange<0 & res_R$pvalue<0.05), 'RA_label'] <- 'down'
names(res_R)[2] <- 'RA_log2FC'

# Horizontally merge data
gd <- merge(gd, res_B[,c('asv_id','BA_log2FC','BA_label')], by = c('asv_id'), all.x = T)
gd <- merge(gd, res_R[,c('asv_id','RA_log2FC','RA_label')], by = c('asv_id'), all.x = T)

rm(B, B2, R, R2, dds_B, dds_R, group, res_B, res_R, table) # Remove intermediate variables


# 4. Add consistency markers for up or down regulation in black and red soils
gd[BG_label=="up" & RG_label=='up', "G_consistency"] <- 'up'
gd[BG_label=="down" & RG_label=='down', "G_consistency"] <- 'down'
gd[BM_label=="up" & RM_label=='up', "M_consistency"] <- 'up'
gd[BM_label=="down" & RM_label=='down', "M_consistency"] <- 'down'
gd[BA_label=="up" & RA_label=='up', "A_consistency"] <- 'up'
gd[BA_label=="down" & RA_label=='down', "A_consistency"] <- 'down'


# 5. Add taxonomic information, original asv_id and sequences, split black and red soil data (based on whether growth rate log2FC is NA), 
#    add average values of growth rate, mortality rate, abundance, and relative abundance for P0 and P2 treatments

# asv_info <- read.delim("ASV_originID_tax.xls", check.names = F, stringsAsFactors = F)
# asv_info$taxonomy <- gsub("[a-z]__", "", asv_info$taxonomy)  # Remove taxonomic prefixes
# asv_info <- tidyr::separate(asv_info, col = 3, into = c('kingdom','phylum','class','order','family','genus','species'), sep = ";")  # Split taxonomic column
# asv_info[which(str_detect(asv_info$genus, "uncultured") | is.na(asv_info$genus)), 'genus'] <- 'unknown_genus' # Modify unclassified genera
# asv_info$tax_label <- paste(asv_info$asv_id, asv_info$genus)  # asv_id + genus as text label for tree building
# 
# seqs <- read.delim("rep-seqs.fasta", header = F, check.names = F, stringsAsFactors = F) # Read rep-seqs
# read_fasta <- function(seq){ # Read fasta format file, adjust to two columns
#   seq3 <- data.frame(stringsAsFactors = FALSE)
#   n <- 0
#   r <- nrow(seq)
#   for (i in 1:r) {
#     cat(i, "/", r, "\r")
#     if (grepl(">", seq[i,1])) {
#       n <- n + 1
#       seq3[n,'ID'] <- seq[i,1]
#       seq3[n,'seq'] <- ''
#     } else {
#       seq3[n,'seq'] <- paste(seq3[n,'seq'], seq[i,1], sep = '')
#     }
#   }
#   # seq3$seq <- gsub(' ', '', seq3$seq)  # Remove spaces in sequences
#   # seq3$ID <- str_extract(seq3$ID, "^>.+[.]{1}[:digit:]+") # Keep only sequence ID
#   # seq3 <- seq3[which((!duplicated(seq3$ID))&(!duplicated(seq3$seq))),] # Remove ID and seq duplicates
#   return(seq3)
# }
# seqs <- read_fasta(seqs) # Adjust fasta format to two columns
# seqs$ID <- gsub(">", "", seqs$ID) # Remove > before sequence ID
# 
# asv_info <- merge(asv_info, seqs, by.x="origin_asv_name", by.y="ID", all.x=T) # Add sequences to asv_info
# write.table(asv_info, "asv_info.xls", sep = '\t', quote = F, row.names = F)  # Output asv_info

# Read already prepared ASV information
asv_info <- read.delim("asv_info.xls", check.names = F, stringsAsFactors = F)

# Add asv information to gd results
gd <- merge(gd, asv_info, by='asv_id', all.x = T)  

# Split black and red soil data (based on whether growth rate log2FC is NA)
B_gd <- copy(gd)  # Copy gd, otherwise changes will be made to gd variable in the next step
B_gd[, ':='(RG_log2FC=NULL, RG_label=NULL, RM_log2FC=NULL, RM_label=NULL, RA_log2FC=NULL, RA_label=NULL)] # Remove red soil data columns
B_gd <- B_gd[!is.na(BG_log2FC),]  # Keep only rows where BG_log2FC is not NA
R_gd <- copy(gd)  # Copy gd, otherwise changes will be made to gd variable in the next step
R_gd[, ':='(BG_log2FC=NULL, BG_label=NULL, BM_log2FC=NULL, BM_label=NULL, BA_log2FC=NULL, BA_label=NULL)] # Remove black soil data columns
R_gd <- R_gd[!is.na(RG_log2FC),]  # Keep only rows where RG_log2FC is not NA

# Add average values of growth rate, mortality rate, abundance, and relative abundance for P0 and P2 treatments
gd2 <- res$pop2[variable %in% c('growth','mortality'),] # Re-read growth and mortality rate data

# Add growth and mortality rates for black soil data
B_gd <- merge(B_gd, gd2[soil=="B" & protist=="P0" & variable=="growth", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(B_gd, "50%", "P0_G")
B_gd <- merge(B_gd, gd2[soil=="B" & protist=="P2" & variable=="growth", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(B_gd, "50%", "P2_G")
B_gd <- merge(B_gd, gd2[soil=="B" & protist=="P0" & variable=="mortality", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(B_gd, "50%", "P0_M")
B_gd <- merge(B_gd, gd2[soil=="B" & protist=="P2" & variable=="mortality", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(B_gd, "50%", "P2_M")

# Add growth and mortality rates for red soil data
R_gd <- merge(R_gd, gd2[soil=="R" & protist=="P0" & variable=="growth", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(R_gd, "50%", "P0_G")
R_gd <- merge(R_gd, gd2[soil=="R" & protist=="P2" & variable=="growth", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(R_gd, "50%", "P2_G")
R_gd <- merge(R_gd, gd2[soil=="R" & protist=="P0" & variable=="mortality", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(R_gd, "50%", "P0_M")
R_gd <- merge(R_gd, gd2[soil=="R" & protist=="P2" & variable=="mortality", c("asv_id","50%")], by='asv_id', all.x = T)
setnames(R_gd, "50%", "P2_M")

# Re-read abundance information from table
table <- res$table
table <- table[, str_detect(names(table), "_")]  # Extract data columns
rel_table <- as.data.frame(t(t(table)/colSums(table)))  # Convert to relative abundance table, since when dividing matrix by vector, division is row-wise, first transpose, divide by sample sum, then transpose back

# Add abundance and relative abundance for black soil data
B_gd <- merge(B_gd, data.frame(asv_id=row.names(table), P0_A=rowMeans(table[, str_detect(names(table), "B_P0")])), by='asv_id', all.x = T)  # In data.frame, asv_id is used for merge, rowMeans is average of 3 replicates per treatment, with column names specified
B_gd <- merge(B_gd, data.frame(asv_id=row.names(table), P2_A=rowMeans(table[, str_detect(names(table), "B_P2")])), by='asv_id', all.x = T)
B_gd <- merge(B_gd, data.frame(asv_id=row.names(rel_table), P0_relA=rowMeans(rel_table[, str_detect(names(rel_table), "B_P0")])), by='asv_id', all.x = T)
B_gd <- merge(B_gd, data.frame(asv_id=row.names(rel_table), P2_relA=rowMeans(rel_table[, str_detect(names(rel_table), "B_P2")])), by='asv_id', all.x = T)

# Add abundance and relative abundance for red soil data
R_gd <- merge(R_gd, data.frame(asv_id=row.names(table), P0_A=rowMeans(table[, str_detect(names(table), "R_P0")])), by='asv_id', all.x = T)  # In data.frame, asv_id is used for merge, rowMeans is average of 3 replicates per treatment, with column names specified
R_gd <- merge(R_gd, data.frame(asv_id=row.names(table), P2_A=rowMeans(table[, str_detect(names(table), "R_P2")])), by='asv_id', all.x = T)
R_gd <- merge(R_gd, data.frame(asv_id=row.names(rel_table), P0_relA=rowMeans(rel_table[, str_detect(names(rel_table), "R_P0")])), by='asv_id', all.x = T)
R_gd <- merge(R_gd, data.frame(asv_id=row.names(rel_table), P2_relA=rowMeans(rel_table[, str_detect(names(rel_table), "R_P2")])), by='asv_id', all.x = T)

# Replace NA with ""
B_gd[is.na(B_gd)] <- ""
R_gd[is.na(R_gd)] <- ""


# 6. Export sequences for tree building and ASV tree building information

# Define function to output fasta format
fasta_output <- function(seq){ # Adjust to fasta format output
  row.names(seq) <- 1:nrow(seq)
  fasta <- data.frame()
  t <- 1
  for (i in 1:nrow(seq)) {
    fasta[t,1] <- seq[i,1]
    fasta[t+1,1] <- seq[i,2]
    t <- t + 2
  }
  return(fasta)
}

# Export black soil sequences
B_seqs <- B_gd[, c('asv_id','seq')]
B_seqs$asv_id <- paste0(">", B_seqs$asv_id)
B_seqs <- fasta_output(B_seqs)
write.table(B_seqs, "B_seqs.fasta", sep = '\t', quote = F, row.names = F, col.names = F)  # Output sequences for tree building (fasta format)

# Export red soil sequences
R_seqs <- R_gd[, c('asv_id','seq')]
R_seqs$asv_id <- paste0(">", R_seqs$asv_id)
R_seqs <- fasta_output(R_seqs)
write.table(R_seqs, "R_seqs.fasta", sep = '\t', quote = F, row.names = F, col.names = F)  # Output sequences for tree building (fasta format)

# Export sequences of top 200 relative abundance (P2_relA) under P2 treatment
B_gd <- B_gd[order(P2_relA, decreasing = T),]  # Sort by P2_relA
R_gd <- R_gd[order(P2_relA, decreasing = T),]  # Sort by P2_relA

# Export black soil sequences
B_seqs <- B_gd[1:200, c('asv_id','seq')]
B_seqs$asv_id <- paste0(">", B_seqs$asv_id)
B_seqs <- fasta_output(B_seqs)
write.table(B_seqs, "B_seqs_relA_top200.fasta", sep = '\t', quote = F, row.names = F, col.names = F)  # Output sequences for tree building (fasta format)

# Export red soil sequences
R_seqs <- R_gd[1:200, c('asv_id','seq')]
R_seqs$asv_id <- paste0(">", R_seqs$asv_id)
R_seqs <- fasta_output(R_seqs)
write.table(R_seqs, "R_seqs_relA_top200.fasta", sep = '\t', quote = F, row.names = F, col.names = F)  # Output sequences for tree building (fasta format)

# Export ASV tree building information
write.table(B_gd, "B_qSIP_tree_data.xls", sep = '\t', quote = F, row.names = F)  # Output black soil tree building information
write.table(R_gd, "R_qSIP_tree_data.xls", sep = '\t', quote = F, row.names = F)  # Output red soil tree building information
